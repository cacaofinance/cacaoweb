{"ast":null,"code":"var _regeneratorRuntime = require(\"C:/Users/Matias/Downloads/new/svy.finance/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:/Users/Matias/Downloads/new/svy.finance/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"C:/Users/Matias/Downloads/new/svy.finance/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/Matias/Downloads/new/svy.finance/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"C:/Users/Matias/Downloads/new/svy.finance/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _get = require(\"C:/Users/Matias/Downloads/new/svy.finance/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"C:/Users/Matias/Downloads/new/svy.finance/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:/Users/Matias/Downloads/new/svy.finance/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"C:/Users/Matias/Downloads/new/svy.finance/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar EthQuery = require('eth-query');\n\nvar pify = require('pify');\n\nvar SafeEventEmitter = require('safe-event-emitter');\n\nvar sec = 1000;\n\nvar calculateSum = function calculateSum(accumulator, currentValue) {\n  return accumulator + currentValue;\n};\n\nvar blockTrackerEvents = ['sync', 'latest'];\n\nvar BaseBlockTracker = /*#__PURE__*/function (_SafeEventEmitter) {\n  \"use strict\";\n\n  _inherits(BaseBlockTracker, _SafeEventEmitter);\n\n  var _super = _createSuper(BaseBlockTracker);\n\n  //\n  // public\n  //\n  function BaseBlockTracker() {\n    var _this;\n\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, BaseBlockTracker);\n\n    _this = _super.call(this); // config\n\n    _this._blockResetDuration = opts.blockResetDuration || 20 * sec; // state\n\n    _this._blockResetTimeout;\n    _this._currentBlock = null;\n    _this._isRunning = false; // bind functions for internal use\n\n    _this._onNewListener = _this._onNewListener.bind(_assertThisInitialized(_this));\n    _this._onRemoveListener = _this._onRemoveListener.bind(_assertThisInitialized(_this));\n    _this._resetCurrentBlock = _this._resetCurrentBlock.bind(_assertThisInitialized(_this)); // listen for handler changes\n\n    _this._setupInternalEvents();\n\n    return _this;\n  }\n\n  _createClass(BaseBlockTracker, [{\n    key: \"isRunning\",\n    value: function isRunning() {\n      return this._isRunning;\n    }\n  }, {\n    key: \"getCurrentBlock\",\n    value: function getCurrentBlock() {\n      return this._currentBlock;\n    }\n  }, {\n    key: \"getLatestBlock\",\n    value: function () {\n      var _getLatestBlock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _this2 = this;\n\n        var latestBlock;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this._currentBlock) {\n                  _context.next = 2;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", this._currentBlock);\n\n              case 2:\n                _context.next = 4;\n                return new Promise(function (resolve) {\n                  return _this2.once('latest', resolve);\n                });\n\n              case 4:\n                latestBlock = _context.sent;\n                return _context.abrupt(\"return\", latestBlock);\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getLatestBlock() {\n        return _getLatestBlock.apply(this, arguments);\n      }\n\n      return getLatestBlock;\n    }() // dont allow module consumer to remove our internal event listeners\n\n  }, {\n    key: \"removeAllListeners\",\n    value: function removeAllListeners(eventName) {\n      // perform default behavior, preserve fn arity\n      if (eventName) {\n        _get(_getPrototypeOf(BaseBlockTracker.prototype), \"removeAllListeners\", this).call(this, eventName);\n      } else {\n        _get(_getPrototypeOf(BaseBlockTracker.prototype), \"removeAllListeners\", this).call(this);\n      } // re-add internal events\n\n\n      this._setupInternalEvents(); // trigger stop check just in case\n\n\n      this._onRemoveListener();\n    } //\n    // to be implemented in subclass\n    //\n\n  }, {\n    key: \"_start\",\n    value: function _start() {// default behavior is noop\n    }\n  }, {\n    key: \"_end\",\n    value: function _end() {// default behavior is noop\n    } //\n    // private\n    //\n\n  }, {\n    key: \"_setupInternalEvents\",\n    value: function _setupInternalEvents() {\n      // first remove listeners for idempotence\n      this.removeListener('newListener', this._onNewListener);\n      this.removeListener('removeListener', this._onRemoveListener); // then add them\n\n      this.on('newListener', this._onNewListener);\n      this.on('removeListener', this._onRemoveListener);\n    }\n  }, {\n    key: \"_onNewListener\",\n    value: function _onNewListener(eventName, handler) {\n      // `newListener` is called *before* the listener is added\n      if (!blockTrackerEvents.includes(eventName)) return;\n\n      this._maybeStart();\n    }\n  }, {\n    key: \"_onRemoveListener\",\n    value: function _onRemoveListener(eventName, handler) {\n      // `removeListener` is called *after* the listener is removed\n      if (this._getBlockTrackerEventCount() > 0) return;\n\n      this._maybeEnd();\n    }\n  }, {\n    key: \"_maybeStart\",\n    value: function _maybeStart() {\n      if (this._isRunning) return;\n      this._isRunning = true; // cancel setting latest block to stale\n\n      this._cancelBlockResetTimeout();\n\n      this._start();\n    }\n  }, {\n    key: \"_maybeEnd\",\n    value: function _maybeEnd() {\n      if (!this._isRunning) return;\n      this._isRunning = false;\n\n      this._setupBlockResetTimeout();\n\n      this._end();\n    }\n  }, {\n    key: \"_getBlockTrackerEventCount\",\n    value: function _getBlockTrackerEventCount() {\n      var _this3 = this;\n\n      return blockTrackerEvents.map(function (eventName) {\n        return _this3.listenerCount(eventName);\n      }).reduce(calculateSum);\n    }\n  }, {\n    key: \"_newPotentialLatest\",\n    value: function _newPotentialLatest(newBlock) {\n      var currentBlock = this._currentBlock; // only update if blok number is higher\n\n      if (currentBlock && hexToInt(newBlock) <= hexToInt(currentBlock)) return;\n\n      this._setCurrentBlock(newBlock);\n    }\n  }, {\n    key: \"_setCurrentBlock\",\n    value: function _setCurrentBlock(newBlock) {\n      var oldBlock = this._currentBlock;\n      this._currentBlock = newBlock;\n      this.emit('latest', newBlock);\n      this.emit('sync', {\n        oldBlock: oldBlock,\n        newBlock: newBlock\n      });\n    }\n  }, {\n    key: \"_setupBlockResetTimeout\",\n    value: function _setupBlockResetTimeout() {\n      // clear any existing timeout\n      this._cancelBlockResetTimeout(); // clear latest block when stale\n\n\n      this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this._blockResetDuration); // nodejs - dont hold process open\n\n      if (this._blockResetTimeout.unref) {\n        this._blockResetTimeout.unref();\n      }\n    }\n  }, {\n    key: \"_cancelBlockResetTimeout\",\n    value: function _cancelBlockResetTimeout() {\n      clearTimeout(this._blockResetTimeout);\n    }\n  }, {\n    key: \"_resetCurrentBlock\",\n    value: function _resetCurrentBlock() {\n      this._currentBlock = null;\n    }\n  }]);\n\n  return BaseBlockTracker;\n}(SafeEventEmitter);\n\nmodule.exports = BaseBlockTracker;\n\nfunction hexToInt(hexInt) {\n  return Number.parseInt(hexInt, 16);\n}","map":{"version":3,"sources":["C:/Users/Matias/Downloads/new/svy.finance/node_modules/eth-block-tracker/src/base.js"],"names":["EthQuery","require","pify","SafeEventEmitter","sec","calculateSum","accumulator","currentValue","blockTrackerEvents","BaseBlockTracker","opts","_blockResetDuration","blockResetDuration","_blockResetTimeout","_currentBlock","_isRunning","_onNewListener","bind","_onRemoveListener","_resetCurrentBlock","_setupInternalEvents","Promise","resolve","once","latestBlock","eventName","removeListener","on","handler","includes","_maybeStart","_getBlockTrackerEventCount","_maybeEnd","_cancelBlockResetTimeout","_start","_setupBlockResetTimeout","_end","map","listenerCount","reduce","newBlock","currentBlock","hexToInt","_setCurrentBlock","oldBlock","emit","setTimeout","unref","clearTimeout","module","exports","hexInt","Number","parseInt"],"mappings":"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","sourcesContent":["const EthQuery = require('eth-query')\r\nconst pify = require('pify')\r\nconst SafeEventEmitter = require('safe-event-emitter')\r\n\r\nconst sec = 1000\r\n\r\nconst calculateSum = (accumulator, currentValue) => accumulator + currentValue\r\nconst blockTrackerEvents = ['sync', 'latest']\r\n\r\nclass BaseBlockTracker extends SafeEventEmitter {\r\n\r\n  //\r\n  // public\r\n  //\r\n\r\n  constructor (opts = {}) {\r\n    super()\r\n    // config\r\n    this._blockResetDuration = opts.blockResetDuration || 20 * sec\r\n    // state\r\n    this._blockResetTimeout\r\n    this._currentBlock = null\r\n    this._isRunning = false\r\n    // bind functions for internal use\r\n    this._onNewListener = this._onNewListener.bind(this)\r\n    this._onRemoveListener = this._onRemoveListener.bind(this)\r\n    this._resetCurrentBlock = this._resetCurrentBlock.bind(this)\r\n    // listen for handler changes\r\n    this._setupInternalEvents()\r\n  }\r\n\r\n  isRunning () {\r\n    return this._isRunning\r\n  }\r\n\r\n  getCurrentBlock () {\r\n    return this._currentBlock\r\n  }\r\n\r\n  async getLatestBlock () {\r\n    // return if available\r\n    if (this._currentBlock) return this._currentBlock\r\n    // wait for a new latest block\r\n    const latestBlock = await new Promise(resolve => this.once('latest', resolve))\r\n    // return newly set current block\r\n    return latestBlock\r\n  }\r\n\r\n  // dont allow module consumer to remove our internal event listeners\r\n  removeAllListeners (eventName) {\r\n    // perform default behavior, preserve fn arity\r\n    if (eventName) {\r\n      super.removeAllListeners(eventName)\r\n    } else {\r\n      super.removeAllListeners()\r\n    }\r\n    // re-add internal events\r\n    this._setupInternalEvents()\r\n    // trigger stop check just in case\r\n    this._onRemoveListener()\r\n  }\r\n\r\n  //\r\n  // to be implemented in subclass\r\n  //\r\n\r\n  _start () {\r\n    // default behavior is noop\r\n  }\r\n\r\n  _end () {\r\n    // default behavior is noop\r\n  }\r\n\r\n  //\r\n  // private\r\n  //\r\n\r\n  _setupInternalEvents () {\r\n    // first remove listeners for idempotence\r\n    this.removeListener('newListener', this._onNewListener)\r\n    this.removeListener('removeListener', this._onRemoveListener)\r\n    // then add them\r\n    this.on('newListener', this._onNewListener)\r\n    this.on('removeListener', this._onRemoveListener)\r\n  }\r\n\r\n  _onNewListener (eventName, handler) {\r\n    // `newListener` is called *before* the listener is added\r\n    if (!blockTrackerEvents.includes(eventName)) return\r\n    this._maybeStart()\r\n  }\r\n\r\n  _onRemoveListener (eventName, handler) {\r\n    // `removeListener` is called *after* the listener is removed\r\n    if (this._getBlockTrackerEventCount() > 0) return\r\n    this._maybeEnd()\r\n  }\r\n\r\n  _maybeStart () {\r\n    if (this._isRunning) return\r\n    this._isRunning = true\r\n    // cancel setting latest block to stale\r\n    this._cancelBlockResetTimeout()\r\n    this._start()\r\n  }\r\n\r\n  _maybeEnd () {\r\n    if (!this._isRunning) return\r\n    this._isRunning = false\r\n    this._setupBlockResetTimeout()\r\n    this._end()\r\n  }\r\n\r\n  _getBlockTrackerEventCount () {\r\n    return blockTrackerEvents\r\n      .map(eventName => this.listenerCount(eventName))\r\n      .reduce(calculateSum)\r\n  }\r\n\r\n  _newPotentialLatest (newBlock) {\r\n    const currentBlock = this._currentBlock\r\n    // only update if blok number is higher\r\n    if (currentBlock && (hexToInt(newBlock) <= hexToInt(currentBlock))) return\r\n    this._setCurrentBlock(newBlock)\r\n  }\r\n\r\n  _setCurrentBlock (newBlock) {\r\n    const oldBlock = this._currentBlock\r\n    this._currentBlock = newBlock\r\n    this.emit('latest', newBlock)\r\n    this.emit('sync', { oldBlock, newBlock })\r\n  }\r\n\r\n  _setupBlockResetTimeout () {\r\n    // clear any existing timeout\r\n    this._cancelBlockResetTimeout()\r\n    // clear latest block when stale\r\n    this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this._blockResetDuration)\r\n    // nodejs - dont hold process open\r\n    if (this._blockResetTimeout.unref) {\r\n      this._blockResetTimeout.unref()\r\n    }\r\n  }\r\n\r\n  _cancelBlockResetTimeout () {\r\n    clearTimeout(this._blockResetTimeout)\r\n  }\r\n\r\n  _resetCurrentBlock () {\r\n    this._currentBlock = null\r\n  }\r\n\r\n}\r\n\r\nmodule.exports = BaseBlockTracker\r\n\r\nfunction hexToInt(hexInt) {\r\n  return Number.parseInt(hexInt, 16)\r\n}\r\n"]},"metadata":{},"sourceType":"script"}