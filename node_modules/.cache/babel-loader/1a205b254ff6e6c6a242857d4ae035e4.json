{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst tslib_1 = require(\"tslib\");\n\nconst isoCrypto = tslib_1.__importStar(require(\"@pedrouid/iso-crypto\"));\n\nconst encUtils = tslib_1.__importStar(require(\"enc-utils\"));\n\nconst utils_1 = require(\"@walletconnect/utils\");\n\nfunction generateKey(length) {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    const _length = (length || 256) / 8;\n\n    const bytes = isoCrypto.randomBytes(_length);\n    const result = utils_1.convertBufferToArrayBuffer(encUtils.arrayToBuffer(bytes));\n    return result;\n  });\n}\n\nexports.generateKey = generateKey;\n\nfunction verifyHmac(payload, key) {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    const cipherText = encUtils.hexToArray(payload.data);\n    const iv = encUtils.hexToArray(payload.iv);\n    const hmac = encUtils.hexToArray(payload.hmac);\n    const hmacHex = encUtils.arrayToHex(hmac, false);\n    const unsigned = encUtils.concatArrays(cipherText, iv);\n    const chmac = yield isoCrypto.hmacSha256Sign(key, unsigned);\n    const chmacHex = encUtils.arrayToHex(chmac, false);\n\n    if (encUtils.removeHexPrefix(hmacHex) === encUtils.removeHexPrefix(chmacHex)) {\n      return true;\n    }\n\n    return false;\n  });\n}\n\nexports.verifyHmac = verifyHmac;\n\nfunction encrypt(data, key, providedIv) {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    const _key = encUtils.bufferToArray(utils_1.convertArrayBufferToBuffer(key));\n\n    const ivArrayBuffer = providedIv || (yield generateKey(128));\n    const iv = encUtils.bufferToArray(utils_1.convertArrayBufferToBuffer(ivArrayBuffer));\n    const ivHex = encUtils.arrayToHex(iv, false);\n    const contentString = JSON.stringify(data);\n    const content = encUtils.utf8ToArray(contentString);\n    const cipherText = yield isoCrypto.aesCbcEncrypt(iv, _key, content);\n    const cipherTextHex = encUtils.arrayToHex(cipherText, false);\n    const unsigned = encUtils.concatArrays(cipherText, iv);\n    const hmac = yield isoCrypto.hmacSha256Sign(_key, unsigned);\n    const hmacHex = encUtils.arrayToHex(hmac, false);\n    return {\n      data: cipherTextHex,\n      hmac: hmacHex,\n      iv: ivHex\n    };\n  });\n}\n\nexports.encrypt = encrypt;\n\nfunction decrypt(payload, key) {\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    const _key = encUtils.bufferToArray(utils_1.convertArrayBufferToBuffer(key));\n\n    if (!_key) {\n      throw new Error(\"Missing key: required for decryption\");\n    }\n\n    const verified = yield verifyHmac(payload, _key);\n\n    if (!verified) {\n      return null;\n    }\n\n    const cipherText = encUtils.hexToArray(payload.data);\n    const iv = encUtils.hexToArray(payload.iv);\n    const buffer = yield isoCrypto.aesCbcDecrypt(iv, _key, cipherText);\n    const utf8 = encUtils.arrayToUtf8(buffer);\n    let data;\n\n    try {\n      data = JSON.parse(utf8);\n    } catch (error) {\n      return null;\n    }\n\n    return data;\n  });\n}\n\nexports.decrypt = decrypt;","map":{"version":3,"sources":["../../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst tslib_1 = require(\"tslib\");\r\nconst isoCrypto = tslib_1.__importStar(require(\"@pedrouid/iso-crypto\"));\r\nconst encUtils = tslib_1.__importStar(require(\"enc-utils\"));\r\nconst utils_1 = require(\"@walletconnect/utils\");\r\nfunction generateKey(length) {\r\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\r\n        const _length = (length || 256) / 8;\r\n        const bytes = isoCrypto.randomBytes(_length);\r\n        const result = utils_1.convertBufferToArrayBuffer(encUtils.arrayToBuffer(bytes));\r\n        return result;\r\n    });\r\n}\r\nexports.generateKey = generateKey;\r\nfunction verifyHmac(payload, key) {\r\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\r\n        const cipherText = encUtils.hexToArray(payload.data);\r\n        const iv = encUtils.hexToArray(payload.iv);\r\n        const hmac = encUtils.hexToArray(payload.hmac);\r\n        const hmacHex = encUtils.arrayToHex(hmac, false);\r\n        const unsigned = encUtils.concatArrays(cipherText, iv);\r\n        const chmac = yield isoCrypto.hmacSha256Sign(key, unsigned);\r\n        const chmacHex = encUtils.arrayToHex(chmac, false);\r\n        if (encUtils.removeHexPrefix(hmacHex) === encUtils.removeHexPrefix(chmacHex)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    });\r\n}\r\nexports.verifyHmac = verifyHmac;\r\nfunction encrypt(data, key, providedIv) {\r\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\r\n        const _key = encUtils.bufferToArray(utils_1.convertArrayBufferToBuffer(key));\r\n        const ivArrayBuffer = providedIv || (yield generateKey(128));\r\n        const iv = encUtils.bufferToArray(utils_1.convertArrayBufferToBuffer(ivArrayBuffer));\r\n        const ivHex = encUtils.arrayToHex(iv, false);\r\n        const contentString = JSON.stringify(data);\r\n        const content = encUtils.utf8ToArray(contentString);\r\n        const cipherText = yield isoCrypto.aesCbcEncrypt(iv, _key, content);\r\n        const cipherTextHex = encUtils.arrayToHex(cipherText, false);\r\n        const unsigned = encUtils.concatArrays(cipherText, iv);\r\n        const hmac = yield isoCrypto.hmacSha256Sign(_key, unsigned);\r\n        const hmacHex = encUtils.arrayToHex(hmac, false);\r\n        return {\r\n            data: cipherTextHex,\r\n            hmac: hmacHex,\r\n            iv: ivHex,\r\n        };\r\n    });\r\n}\r\nexports.encrypt = encrypt;\r\nfunction decrypt(payload, key) {\r\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\r\n        const _key = encUtils.bufferToArray(utils_1.convertArrayBufferToBuffer(key));\r\n        if (!_key) {\r\n            throw new Error(\"Missing key: required for decryption\");\r\n        }\r\n        const verified = yield verifyHmac(payload, _key);\r\n        if (!verified) {\r\n            return null;\r\n        }\r\n        const cipherText = encUtils.hexToArray(payload.data);\r\n        const iv = encUtils.hexToArray(payload.iv);\r\n        const buffer = yield isoCrypto.aesCbcDecrypt(iv, _key, cipherText);\r\n        const utf8 = encUtils.arrayToUtf8(buffer);\r\n        let data;\r\n        try {\r\n            data = JSON.parse(utf8);\r\n        }\r\n        catch (error) {\r\n            return null;\r\n        }\r\n        return data;\r\n    });\r\n}\r\nexports.decrypt = decrypt;\r\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}